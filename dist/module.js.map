{"mappings":"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","sources":["src/index.ts","src/binaryreader.ts","src/binarywriter.ts","src/wktparser.ts","src/types.ts","src/point.ts","src/base.ts","src/zigzag.ts","src/polygon.ts","src/linestring.ts","src/multipoint.ts","src/parser.ts","src/multipolygon.ts","src/multilinestring.ts","src/geometrycollection.ts"],"sourcesContent":["import { BinaryReader } from \"./binaryreader\";\r\nimport { BinaryWriter } from \"./binarywriter\";\r\nimport { WktParser } from \"./wktparser\";\r\nimport { Point } from \"./point\";\r\nimport { Polygon } from \"./polygon\";\r\nimport { LineString } from \"./linestring\";\r\nimport { MultiPoint } from \"./multipoint\";\r\nimport { MultiPolygon } from \"./multipolygon\";\r\nimport { MultiLineString } from \"./multilinestring\";\r\nimport { GeometryCollection } from \"./geometrycollection\";\r\n\r\nexport {\r\n    BinaryReader,\r\n    BinaryWriter,\r\n    WktParser,\r\n    Point,\r\n    Polygon,\r\n    LineString,\r\n    MultiPoint,\r\n    MultiPolygon,\r\n    MultiLineString,\r\n    GeometryCollection\r\n}","export class BinaryReader {\n  private buffer: DataView;\n  private position: number;\n\n  public isBigEndian: boolean;\n\n  constructor(buffer: DataView, isBigEndian: boolean = false) {\n    this.buffer = buffer;\n    this.position = 0;\n    this.isBigEndian = isBigEndian;\n  }\n\n  public readUInt8(): number {\n    const result = this.buffer.getUint8(this.position);\n\n    ++this.position;\n\n    return result;\n  }\n\n  public readUInt16(): number {\n    const result = this.buffer.getUint16(this.position, !this.isBigEndian);\n\n    this.position += 2;\n\n    return result;\n  }\n\n  public readUInt32(): number {\n    const result = this.buffer.getUint32(this.position, !this.isBigEndian);\n\n    this.position += 4;\n\n    return result;\n  }\n\n  public readInt8(): number {\n    const result = this.buffer.getInt8(this.position);\n\n    ++this.position;\n\n    return result;\n  }\n\n  public readInt16(): number {\n    const result = this.buffer.getInt16(this.position, !this.isBigEndian);\n\n    this.position += 2;\n\n    return result;\n  }\n\n  public readInt32(): number {\n    const result = this.buffer.getInt32(this.position, !this.isBigEndian);\n\n    this.position += 4;\n\n    return result;\n  }\n\n  public readFloat(): number {\n    const result = this.buffer.getFloat32(this.position, !this.isBigEndian);\n\n    this.position += 4;\n\n    return result;\n  }\n\n  public readDouble(): number {\n    const result = this.buffer.getFloat64(this.position, !this.isBigEndian);\n\n    this.position += 8;\n\n    return result;\n  }\n\n  public readVarInt(): number {\n    let result = 0;\n    let bytesRead = 0;\n    let nextByte: number;\n\n    do {\n      nextByte = this.buffer.getUint8(this.position + bytesRead);\n      result += (nextByte & 0x7f) << (7 * bytesRead);\n      bytesRead++;\n    } while (nextByte >= 0x80);\n\n    this.position += bytesRead;\n\n    return result;\n  }\n}\n","export class BinaryWriter {\n  public buffer: DataView;\n  public position: number;\n  private allowResize: boolean;\n\n  constructor(size: number, allowResize: boolean = false) {\n    this.buffer = new DataView(new ArrayBuffer(size));\n    this.position = 0;\n    this.allowResize = allowResize;\n  }\n\n  public writeUInt8(value: number) {\n    this.ensureSize(1);\n    this.buffer.setUint8(this.position, value);\n\n    this.position += 1;\n  }\n\n  public writeUInt16(value: number, littleEndian: boolean = true) {\n    this.ensureSize(2);\n    this.buffer.setUint16(this.position, value, littleEndian);\n\n    this.position += 2;\n  }\n\n  public writeUInt32(value: number, littleEndian: boolean = true) {\n    this.ensureSize(4);\n    this.buffer.setUint32(this.position, value, littleEndian);\n\n    this.position += 4;\n  }\n\n  public writeInt8(value: number) {\n    this.ensureSize(1);\n    this.buffer.setInt8(this.position, value);\n\n    this.position += 1;\n  }\n\n  public writeInt16(value: number, littleEndian: boolean = true) {\n    this.ensureSize(2);\n    this.buffer.setInt16(this.position, value, littleEndian);\n\n    this.position += 2;\n  }\n\n  public writeInt32(value: number, littleEndian: boolean = true) {\n    this.ensureSize(4);\n    this.buffer.setInt32(this.position, value, littleEndian);\n\n    this.position += 4;\n  }\n\n  public writeFloat(value: number, littleEndian: boolean = true) {\n    this.ensureSize(4);\n    this.buffer.setFloat32(this.position, value, littleEndian);\n\n    this.position += 4;\n  }\n\n  public writeDouble(value: number, littleEndian: boolean = true) {\n    this.ensureSize(8);\n    this.buffer.setFloat64(this.position, value, littleEndian);\n\n    this.position += 8;\n  }\n\n  public writeBuffer(buffer: ArrayBuffer) {\n    this.ensureSize(buffer.byteLength);\n\n    new Uint8Array(this.buffer.buffer).set(new Uint8Array(buffer), this.position);\n    this.position += buffer.byteLength;\n  }\n\n  public writeVarInt(value: number) {\n    let length = 1;\n  \n    while ((value & 0xffffff80) !== 0) {\n      this.writeUInt8((value & 0x7f) | 0x80);\n      value >>>= 7;\n      length++;\n    }\n  \n    this.writeUInt8(value & 0x7f);\n  \n    return length;\n  };\n\n  private ensureSize(size: number) {\n    if (this.buffer.byteLength >= this.position + size) return;\n\n    if (!this.allowResize) throw new RangeError(\"index out of range\");\n\n    const tempBuffer = new DataView(new ArrayBuffer(this.position + size));\n    new Uint8Array(tempBuffer.buffer).set(new Uint8Array(this.buffer.buffer));\n    this.buffer = tempBuffer;\n  }\n}\n","import { Types, WKTParseOptions } from \"./types\";\n\nexport class WktParser {\n  private position: number;\n  private value: string;\n\n  constructor(value: string) {\n    this.value = value;\n    this.position = 0;\n  }\n\n  public matchRegex(tokens: RegExp[]) {\n    this.skipWhitespaces();\n  \n    for (let i = 0; i < tokens.length; i++) {\n      const match = this.value.substring(this.position).match(tokens[i]);\n  \n      if (match) {\n        this.position += match[0].length;\n        return match;\n      }\n    }\n  \n    return null;\n  };\n\n  private match(tokens: string[]) {\n    this.skipWhitespaces();\n\n    for (let i = 0; i < tokens.length; i++) {\n      if (this.value.substring(this.position).indexOf(tokens[i]) === 0) {\n        this.position += tokens[i].length;\n        return tokens[i];\n      }\n    }\n\n    return null;\n  }\n\n  public matchDimension(): WKTParseOptions {\n    const dimension = this.match(['ZM', 'Z', 'M']);\n  \n    switch (dimension) {\n      case 'ZM': return { hasZ: true, hasM: true };\n      case 'Z': return { hasZ: true, hasM: false };\n      case 'M': return { hasZ: false, hasM: true };\n      default: return { hasZ: false, hasM: false };\n    }\n  };\n\n  public isMatch(tokens: string[]) {\n    this.skipWhitespaces();\n  \n    for (let i = 0; i < tokens.length; i++) {\n      if (this.value.substring(this.position).indexOf(tokens[i]) === 0) {\n        this.position += tokens[i].length;\n        return true;\n      }\n    }\n  \n    return false;\n  };\n\n  public matchType() {\n    const geometryType = this.match([Types.wkt.Point, Types.wkt.LineString, Types.wkt.Polygon, Types.wkt.MultiPoint,\n    Types.wkt.MultiLineString, Types.wkt.MultiPolygon, Types.wkt.GeometryCollection]);\n  \n    if (!geometryType)\n      throw new Error('Expected geometry type');\n  \n    return geometryType;\n  };\n\n  public expectGroupStart() {\n    if (!this.isMatch(['(']))\n      throw new Error('Expected group start');\n  };\n  \n  public expectGroupEnd() {\n    if (!this.isMatch([')']))\n      throw new Error('Expected group end');\n  };\n  \n  public matchCoordinate(options: WKTParseOptions) {\n    let match;\n  \n    if (options.hasZ && options.hasM)\n      match = this.matchRegex([/^(\\S*)\\s+(\\S*)\\s+(\\S*)\\s+([^\\s,)]*)/]);\n    else if (options.hasZ || options.hasM)\n      match = this.matchRegex([/^(\\S*)\\s+(\\S*)\\s+([^\\s,)]*)/]);\n    else\n      match = this.matchRegex([/^(\\S*)\\s+([^\\s,)]*)/]);\n  \n    if (!match)\n      throw new Error('Expected coordinates');\n  \n    if (options.hasZ && options.hasM)\n      return [parseFloat(match[1]), parseFloat(match[2]), parseFloat(match[3]), parseFloat(match[4])];\n    else if (options.hasZ)\n      return [parseFloat(match[1]), parseFloat(match[2]), parseFloat(match[3]), undefined];\n    else if (options.hasM)\n      return [parseFloat(match[1]), parseFloat(match[2]), undefined, parseFloat(match[3])];\n    else\n      return [parseFloat(match[1]), parseFloat(match[2]), undefined, undefined];\n  };\n  \n  public matchCoordinates(options: WKTParseOptions) {\n    const coordinates = [];\n  \n    do {\n      const startsWithBracket = this.isMatch(['(']);\n  \n      coordinates.push(this.matchCoordinate(options));\n  \n      if (startsWithBracket)\n        this.expectGroupEnd();\n    } while (this.isMatch([',']));\n  \n    return coordinates;\n  };\n\n  private skipWhitespaces() \n  {\n    while (this.position < this.value.length && this.value[this.position] === ' ')\n      this.position++;\n  }\n}\n\n","export const Types = {\n  wkt: {\n    Point: 'POINT',\n    LineString: 'LINESTRING',\n    Polygon: 'POLYGON',\n    MultiPoint: 'MULTIPOINT',\n    MultiLineString: 'MULTILINESTRING',\n    MultiPolygon: 'MULTIPOLYGON',\n    GeometryCollection: 'GEOMETRYCOLLECTION'\n  },\n  wkb: {\n    Point: 1,\n    LineString: 2,\n    Polygon: 3,\n    MultiPoint: 4,\n    MultiLineString: 5,\n    MultiPolygon: 6,\n    GeometryCollection: 7\n  },\n  geoJSON: {\n    Point: 'Point',\n    LineString: 'LineString',\n    Polygon: 'Polygon',\n    MultiPoint: 'MultiPoint',\n    MultiLineString: 'MultiLineString',\n    MultiPolygon: 'MultiPolygon',\n    GeometryCollection: 'GeometryCollection'\n  }\n};\n\nexport interface WKBExportOptions {\n  srid?: number;\n}\n\nexport interface WKTParseOptions {\n  srid?: number;\n  hasZ: boolean;\n  hasM: boolean;\n}\n\nexport interface WKBParseOptions {\n  srid?: number;\n\n  hasSrid: boolean;\n  hasZ: boolean;\n  hasM: boolean;\n  isEwkb: boolean;\n}\n\nexport interface Precision {\n  xy: number;\n  z: number;\n  m: number;\n  xyFactor:number;\n  zFactor: number;\n  mFactor: number;\n}\n\nexport interface TWKBParseOptions {\n  precision: number;\n  precisionFactor: number;\n\n  hasBoundingBox: boolean;\n  hasSizeAttribute: boolean;\n  hasIdList: boolean;\n  hasExtendedPrecision: boolean;\n  isEmpty: boolean;\n\n  hasZ: boolean;\n  hasM: boolean;\n\n  zPrecision: number;\n  zPrecisionFactor: number;\n\n  mPrecision: number;\n  mPrecisionFactor: number;\n}","import { BinaryReader } from \"./binaryreader\";\nimport { Types, TWKBParseOptions, Precision, WKTParseOptions, WKBParseOptions, WKBExportOptions } from \"./types\";\nimport { WktParser } from \"./wktparser\";\nimport { BinaryWriter } from \"./binarywriter\";\nimport { GeometryBase } from \"./base\";\nimport { decode, encode } from \"./zigzag\";\n\nexport class Point extends GeometryBase {\n  public x?: number;\n  public y?: number;\n  public z?: number;\n  public m?: number;\n\n  constructor(x?: number, y?: number, z?: number, m?: number, srid?: number) {\n    super();\n\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.m = m;\n    this.srid = srid;\n\n    this.hasZ = this.z !== undefined;\n    this.hasM = this.m !== undefined;\n  }\n\n  public static Z(x: number, y: number, z: number, srid: number) {\n    const point = new Point(x, y, z, undefined, srid);\n    point.hasZ = true;\n    return point;\n  };\n\n  public static M(x: number, y: number, m: number, srid: number) {\n    const point = new Point(x, y, undefined, m, srid);\n    point.hasM = true;\n    return point;\n  };\n\n  public static ZM(x: number, y: number, z: number, m: number, srid: number) {\n    const point = new Point(x, y, z, m, srid);\n    point.hasZ = true;\n    point.hasM = true;\n    return point;\n  };\n\n  //#region Static parsers\n\n  public static parseWkt(reader: WktParser, options: WKTParseOptions): Point {\n    const point = new Point();\n    point.srid = options.srid;\n    point.hasZ = options.hasZ;\n    point.hasM = options.hasM;\n\n    if (reader.isMatch(['EMPTY']))\n      return point;\n\n    reader.expectGroupStart();\n\n    [point.x, point.y, point.z, point.m] = reader.matchCoordinate(options);\n\n    reader.expectGroupEnd();\n\n    return point;\n  }\n\n  public static parseWkb(reader: BinaryReader, options: WKBParseOptions): Point {\n    const point = Point.readWkbPoint(reader, options);\n    point.srid = options.srid;\n    return point;\n  }\n\n  public static readWkbPoint(reader: BinaryReader, options: WKBParseOptions) {\n    return new Point(reader.readDouble(), reader.readDouble(),\n      options.hasZ ? reader.readDouble() : undefined,\n      options.hasM ? reader.readDouble() : undefined);\n  };\n\n  public static parseTwkb(reader: BinaryReader, options: TWKBParseOptions): Point {\n    const point = new Point();\n    point.hasZ = options.hasZ;\n    point.hasM = options.hasM;\n\n    if (options.isEmpty)\n      return point;\n\n    point.x = decode(reader.readVarInt()) / options.precisionFactor;\n    point.y = decode(reader.readVarInt()) / options.precisionFactor;\n    point.z = options.hasZ ? decode(reader.readVarInt()) / options.zPrecisionFactor : undefined;\n    point.m = options.hasM ? decode(reader.readVarInt()) / options.mPrecisionFactor : undefined;\n\n    return point;\n  }\n\n  public static readTwkbPoint(reader: BinaryReader, options: TWKBParseOptions, previousPoint: Point): Point {\n    previousPoint.x! += decode(reader.readVarInt()) / options.precisionFactor;\n    previousPoint.y! += decode(reader.readVarInt()) / options.precisionFactor;\n\n    if (options.hasZ)\n      previousPoint.z! += decode(reader.readVarInt()) / options.zPrecisionFactor;\n    if (options.hasM)\n      previousPoint.m! += decode(reader.readVarInt()) / options.mPrecisionFactor;\n\n    return new Point(previousPoint.x, previousPoint.y, previousPoint.z, previousPoint.m);\n  }\n\n  //#endregion\n\n  public toWkt(): string {\n    if (this.x === undefined && this.y === undefined && this.z === undefined && this.m === undefined)\n      return this.getWktType(Types.wkt.Point, true);\n\n    return this.getWktType(Types.wkt.Point, false) + '(' + this.getWktCoordinate() + ')';\n  }\n\n  public toWkb(options?: WKBExportOptions): ArrayBuffer {\n    var wkb = new BinaryWriter(this.getWkbSize(), false);\n\n    wkb.writeInt8(1);\n    wkb.writeUInt32(this.getWkbType(Types.wkb.Point, options));\n\n    if (this.x === undefined && this.y === undefined) {\n      wkb.writeDouble(NaN);\n      wkb.writeDouble(NaN);\n\n      if (this.hasZ)\n        wkb.writeDouble(NaN);\n      if (this.hasM)\n        wkb.writeDouble(NaN);\n    }\n    else {\n      this.writeWkbPoint(wkb);\n    }\n\n    return wkb.buffer.buffer;\n  }\n\n  public writeWkbPoint(writer: BinaryWriter) {\n    writer.writeDouble(this.x!);\n    writer.writeDouble(this.y!);\n\n    if (this.hasZ)\n      writer.writeDouble(this.z!);\n    if (this.hasM)\n      writer.writeDouble(this.m!);\n  };\n\n  public toTwkb(): ArrayBuffer {\n    const writer = new BinaryWriter(0, true);\n\n    const precision = GeometryBase.getTwkbPrecision(5, 0, 0);\n    const isEmpty = this.x === undefined && this.y === undefined;\n\n    this.writeTwkbHeader(writer, Types.wkb.Point, precision, isEmpty);\n\n    if (!isEmpty)\n      this.writeTwkbPoint(writer, precision, new Point(0, 0, 0, 0));\n\n    return writer.buffer.buffer;\n  }\n\n  public writeTwkbPoint(writer: BinaryWriter, precision: Precision, previousPoint: Point): void {\n    const x = this.x! * precision.xyFactor;\n    const y = this.y! * precision.xyFactor;\n    const z = this.z! * precision.zFactor;\n    const m = this.m! * precision.mFactor;\n\n    writer.writeVarInt(encode(x - previousPoint.x!));\n    writer.writeVarInt(encode(y - previousPoint.y!));\n    if (this.hasZ)\n      writer.writeVarInt(encode(z - previousPoint.z!));\n    if (this.hasM)\n      writer.writeVarInt(encode(m - previousPoint.m!));\n\n    previousPoint.x = x;\n    previousPoint.y = y;\n    previousPoint.z = z;\n    previousPoint.m = m;\n  }\n\n  public getWkbSize(): number {\n    let size = 1 + 4 + 8 + 8;\n\n    if (this.hasZ)\n      size += 8;\n    if (this.hasM)\n      size += 8;\n\n    return size;\n  }\n\n  //#region Public Methods \n\n  public getWktCoordinate(): string {\n    var coordinates = this.x + ' ' + this.y;\n\n    if (this.hasZ)\n      coordinates += ' ' + this.z;\n    if (this.hasM)\n      coordinates += ' ' + this.m;\n\n    return coordinates;\n  }\n\n  //#endregion\n}\n","import { BinaryWriter } from \"./binarywriter\";\r\nimport { Precision, WKBExportOptions } from \"./types\";\r\nimport { encode } from \"./zigzag\";\r\n\r\nexport abstract class GeometryBase {\r\n  public srid?: number;\r\n  public hasZ: boolean;\r\n  public hasM: boolean;\r\n\r\n  constructor() {\r\n    this.srid = undefined;\r\n    this.hasZ = false;\r\n    this.hasM = false;\r\n  }\r\n\r\n  /**\r\n   * Export to WKT format\r\n   */\r\n  public abstract toWkt(): string;\r\n\r\n\r\n  public abstract toWkb(options?: WKBExportOptions): ArrayBuffer;\r\n\r\n  /**\r\n   * Export to WKTB format\r\n   */\r\n  public abstract toTwkb(): ArrayBuffer;\r\n\r\n  /**\r\n   * Get the byte size of the geometry stored in WKB format\r\n   */\r\n  public abstract getWkbSize(): number;\r\n\r\n  public static getTwkbPrecision(xyPrecision: number, zPrecision: number, mPrecision: number): Precision {\r\n    return {\r\n      xy: xyPrecision,\r\n      z: zPrecision,\r\n      m: mPrecision,\r\n      xyFactor: Math.pow(10, xyPrecision),\r\n      zFactor: Math.pow(10, zPrecision),\r\n      mFactor: Math.pow(10, mPrecision)\r\n    };\r\n  };\r\n\r\n  protected writeTwkbHeader(writer: BinaryWriter, geometryType: number, precision: Precision, isEmpty: boolean): void {\r\n    const type = (encode(precision.xy) << 4) + geometryType;\r\n    let metadataHeader = Number(this.hasZ || this.hasM) << 3;\r\n    metadataHeader += Number(isEmpty) << 4;\r\n\r\n    writer.writeUInt8(type);\r\n    writer.writeUInt8(metadataHeader);\r\n\r\n    if (this.hasZ || this.hasM) {\r\n      let extendedPrecision = 0;\r\n      if (this.hasZ)\r\n        extendedPrecision |= 0x1;\r\n      if (this.hasM)\r\n        extendedPrecision |= 0x2;\r\n\r\n      writer.writeUInt8(extendedPrecision);\r\n    }\r\n  }\r\n\r\n  protected getWkbType(geometryType: number, options?: WKBExportOptions): number {\r\n    let dimensionType = 0;\r\n\r\n    if (this.srid === undefined && options?.srid === undefined) {\r\n      if (this.hasZ && this.hasM) dimensionType += 3000;\r\n      else if (this.hasZ) dimensionType += 1000;\r\n      else if (this.hasM) dimensionType += 2000;\r\n    } else {\r\n      if (this.hasZ) dimensionType |= 0x80000000;\r\n      if (this.hasM) dimensionType |= 0x40000000;\r\n    }\r\n\r\n    return (dimensionType + geometryType) >>> 0;\r\n  }\r\n\r\n  protected getWktType(wktType: string, isEmpty: boolean): string {\r\n    let wkt = wktType;\r\n\r\n    if (this.hasZ && this.hasM)\r\n      wkt += ' ZM ';\r\n    else if (this.hasZ)\r\n      wkt += ' Z ';\r\n    else if (this.hasM)\r\n      wkt += ' M ';\r\n\r\n    if (isEmpty && !this.hasZ && !this.hasM)\r\n      wkt += ' ';\r\n\r\n    if (isEmpty)\r\n      wkt += 'EMPTY';\r\n\r\n    return wkt;\r\n  };\r\n\r\n  public toEwkt(): string {\r\n    return 'SRID=' + this.srid + ';' + this.toWkt();\r\n  }\r\n\r\n  public toEwkb(): ArrayBuffer {\r\n    const writer = new BinaryWriter(this.getWkbSize() + 4);\r\n    const buffer = this.toWkb();\r\n\r\n    writer.writeInt8(1);\r\n    writer.writeUInt32((new DataView(buffer.slice(1, 5)).getUint32(0, true) | 0x20000000) >>> 0);\r\n    writer.writeUInt32(this.srid!);\r\n\r\n    writer.writeBuffer(buffer.slice(5));\r\n\r\n    return writer.buffer.buffer;\r\n  };\r\n}","export function encode(value: number): number {\n  return (value << 1) ^ (value >> 31);\n}\n\nexport function decode(value: number): number {\n  return (value >> 1) ^ (-(value & 1));\n}\n\n","import { TWKBParseOptions, Types, WKBExportOptions, WKBParseOptions, WKTParseOptions } from './types';\nimport { Point } from './point';\nimport { BinaryWriter } from './binarywriter';\nimport { WktParser } from './wktparser';\nimport { BinaryReader } from './binaryreader';\nimport { GeometryBase } from './base';\n\nexport class Polygon extends GeometryBase {\n  public exteriorRing: Point[];\n  public interiorRings: Point[][];\n\n  constructor(exteriorRing?: Point[], interiorRings?: Point[][], srid?: number) {\n    super();\n\n    this.exteriorRing = exteriorRing || [];\n    this.interiorRings = interiorRings || [];\n    this.srid = srid;\n\n    if (this.exteriorRing.length > 0) {\n      this.hasZ = this.exteriorRing[0].hasZ;\n      this.hasM = this.exteriorRing[0].hasM;\n    }\n  }\n\n  public static Z = function (exteriorRing: Point[], interiorRings: Point[][], srid: number) {\n    const polygon = new Polygon(exteriorRing, interiorRings, srid);\n    polygon.hasZ = true;\n    return polygon;\n  };\n\n  public static M(exteriorRing: Point[], interiorRings: Point[][], srid: number) {\n    const polygon = new Polygon(exteriorRing, interiorRings, srid);\n    polygon.hasM = true;\n    return polygon;\n  };\n\n  public static ZM(exteriorRing: Point[], interiorRings: Point[][], srid: number) {\n    const polygon = new Polygon(exteriorRing, interiorRings, srid);\n    polygon.hasZ = true;\n    polygon.hasM = true;\n    return polygon;\n  };\n\n  public static parseWkt(reader: WktParser, options: WKTParseOptions): Polygon {\n    let polygon = new Polygon();\n    polygon.srid = options.srid;\n    polygon.hasZ = options.hasZ;\n    polygon.hasM = options.hasM;\n\n    if (reader.isMatch(['EMPTY']))\n      return polygon;\n\n    reader.expectGroupStart();\n\n    reader.expectGroupStart();\n    polygon.exteriorRing = reader.matchCoordinates(options).map(x => new Point(x[0], x[1], x[2], x[3]));\n    reader.expectGroupEnd();\n\n    while (reader.isMatch([','])) {\n      reader.expectGroupStart();\n      polygon.interiorRings.push(reader.matchCoordinates(options).map(x => new Point(x[0], x[1], x[2], x[3])));\n      reader.expectGroupEnd();\n    }\n\n    reader.expectGroupEnd();\n\n    return polygon;\n  }\n\n  public static parseWkb(reader: BinaryReader, options: WKBParseOptions): Polygon {\n    var polygon = new Polygon();\n    polygon.srid = options.srid;\n    polygon.hasZ = options.hasZ;\n    polygon.hasM = options.hasM;\n\n    var ringCount = reader.readUInt32();\n\n    if (ringCount > 0) {\n      var exteriorRingCount = reader.readUInt32();\n\n      for (var i = 0; i < exteriorRingCount; i++)\n        polygon.exteriorRing.push(Point.readWkbPoint(reader, options));\n\n      for (i = 1; i < ringCount; i++) {\n        var interiorRing: Point[] = [];\n\n        var interiorRingCount = reader.readUInt32();\n\n        for (var j = 0; j < interiorRingCount; j++)\n          interiorRing.push(Point.readWkbPoint(reader, options));\n\n        polygon.interiorRings.push(interiorRing);\n      }\n    }\n\n    return polygon;\n  };\n\n  public static parseTwkb(reader: BinaryReader, options: TWKBParseOptions): Polygon {\n    const polygon = new Polygon();\n    polygon.hasZ = options.hasZ;\n    polygon.hasM = options.hasM;\n\n    if (options.isEmpty)\n      return polygon;\n\n    const previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);\n    const ringCount = reader.readVarInt();\n    const exteriorRingCount = reader.readVarInt();\n\n    for (let i = 0; i < exteriorRingCount; i++)\n      polygon.exteriorRing.push(Point.readTwkbPoint(reader, options, previousPoint));\n\n    for (let i = 1; i < ringCount; i++) {\n      const interiorRing = [];\n\n      const interiorRingCount = reader.readVarInt();\n\n      for (let j = 0; j < interiorRingCount; j++)\n        interiorRing.push(Point.readTwkbPoint(reader, options, previousPoint));\n\n      polygon.interiorRings.push(interiorRing);\n    }\n\n    return polygon;\n  }\n\n  public toWkt(): string {\n    if (this.exteriorRing.length === 0)\n      return this.getWktType(Types.wkt.Polygon, true);\n\n    return this.getWktType(Types.wkt.Polygon, false) + this._toInnerWkt();\n  };\n\n  public _toInnerWkt(): string {\n    var innerWkt = '((';\n\n    for (var i = 0; i < this.exteriorRing.length; i++)\n      innerWkt += this.exteriorRing[i].getWktCoordinate() + ',';\n\n    innerWkt = innerWkt.slice(0, -1);\n    innerWkt += ')';\n\n    for (i = 0; i < this.interiorRings.length; i++) {\n      innerWkt += ',(';\n\n      for (var j = 0; j < this.interiorRings[i].length; j++) {\n        innerWkt += this.interiorRings[i][j].getWktCoordinate() + ',';\n      }\n\n      innerWkt = innerWkt.slice(0, -1);\n      innerWkt += ')';\n    }\n\n    innerWkt += ')';\n\n    return innerWkt;\n  };\n\n  public toWkb(options?: WKBExportOptions): ArrayBuffer {\n    var writer = new BinaryWriter(this.getWkbSize());\n\n    writer.writeInt8(1);\n    writer.writeUInt32(this.getWkbType(Types.wkb.Polygon, options));\n\n    if (this.exteriorRing.length > 0) {\n      writer.writeUInt32(1 + this.interiorRings.length);\n      writer.writeUInt32(this.exteriorRing.length);\n    }\n    else {\n      writer.writeUInt32(0);\n    }\n\n    for (let i = 0; i < this.exteriorRing.length; i++)\n      this.exteriorRing[i].writeWkbPoint(writer);\n\n    for (let i = 0; i < this.interiorRings.length; i++) {\n      writer.writeUInt32(this.interiorRings[i].length);\n\n      for (let j = 0; j < this.interiorRings[i].length; j++)\n      this.interiorRings[i][j].writeWkbPoint(writer);\n    }\n\n    return writer.buffer.buffer;\n  };\n\n  public toTwkb(): ArrayBuffer {\n    const writer = new BinaryWriter(0, true);\n\n    const precision = GeometryBase.getTwkbPrecision(5, 0, 0);\n    const isEmpty = this.exteriorRing.length === 0;\n\n    this.writeTwkbHeader(writer, Types.wkb.Polygon, precision, isEmpty);\n\n    if (this.exteriorRing.length > 0) {\n      writer.writeVarInt(1 + this.interiorRings.length);\n\n      writer.writeVarInt(this.exteriorRing.length);\n\n      const previousPoint = new Point(0, 0, 0, 0);\n      for (let i = 0; i < this.exteriorRing.length; i++)\n        this.exteriorRing[i].writeTwkbPoint(writer, precision, previousPoint);\n\n      for (let i = 0; i < this.interiorRings.length; i++) {\n        writer.writeVarInt(this.interiorRings[i].length);\n\n        for (let j = 0; j < this.interiorRings[i].length; j++)\n          this.interiorRings[i][j].writeTwkbPoint(writer, precision, previousPoint);\n      }\n    }\n\n    return writer.buffer.buffer;\n  }\n\n  public getWkbSize(): number {\n    var coordinateSize = 16;\n\n    if (this.hasZ)\n      coordinateSize += 8;\n    if (this.hasM)\n      coordinateSize += 8;\n\n    var size = 1 + 4 + 4;\n\n    if (this.exteriorRing.length > 0)\n      size += 4 + (this.exteriorRing.length * coordinateSize);\n\n    for (var i = 0; i < this.interiorRings.length; i++)\n      size += 4 + (this.interiorRings[i].length * coordinateSize);\n\n    return size;\n  };\n}\n","import { TWKBParseOptions, Types, WKBExportOptions, WKBParseOptions, WKTParseOptions } from './types';\nimport { Point } from './point';\nimport { BinaryReader } from './binaryreader';\nimport { BinaryWriter } from './binarywriter';\nimport { WktParser } from './wktparser';\nimport { GeometryBase } from './base';\n\nexport class LineString extends GeometryBase {\n  public points: Point[];\n\n  constructor(points?: Point[], srid?: number) {\n    super();\n\n    this.points = points || [];\n    this.srid = srid;\n\n    if (this.points.length > 0) {\n      this.hasZ = this.points[0].hasZ;\n      this.hasM = this.points[0].hasM;\n    }\n  }\n\n  public static Z(points: Point[], srid: number) {\n    const lineString = new LineString(points, srid);\n    lineString.hasZ = true;\n    return lineString;\n  };\n\n  public static M(points: Point[], srid: number) {\n    const lineString = new LineString(points, srid);\n    lineString.hasM = true;\n    return lineString;\n  };\n\n  public static ZM(points: Point[], srid: number) {\n    const lineString = new LineString(points, srid);\n    lineString.hasZ = true;\n    lineString.hasM = true;\n    return lineString;\n  };\n\n  public static parseWkt(reader: WktParser, options: WKTParseOptions): LineString {\n    const lineString = new LineString();\n    lineString.srid = options.srid;\n    lineString.hasZ = options.hasZ;\n    lineString.hasM = options.hasM;\n\n    if (reader.isMatch(['EMPTY']))\n      return lineString;\n\n    reader.expectGroupStart();\n    lineString.points = reader.matchCoordinates(options).map(x => new Point(x[0], x[1], x[2], x[3]));\n    reader.expectGroupEnd();\n\n    return lineString;\n  };\n\n  public static parseWkb(reader: BinaryReader, options: WKBParseOptions): LineString {\n    const lineString = new LineString();\n    lineString.srid = options.srid;\n    lineString.hasZ = options.hasZ;\n    lineString.hasM = options.hasM;\n\n    var pointCount = reader.readUInt32();\n\n    for (var i = 0; i < pointCount; i++)\n      lineString.points.push(Point.readWkbPoint(reader, options));\n\n    return lineString;\n  };\n\n  public static parseTwkb(reader: BinaryReader, options: TWKBParseOptions): LineString {\n    const lineString = new LineString();\n    lineString.hasZ = options.hasZ;\n    lineString.hasM = options.hasM;\n\n    if (options.isEmpty)\n      return lineString;\n\n    const previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);\n    const pointCount = reader.readVarInt();\n\n    for (var i = 0; i < pointCount; i++)\n      lineString.points.push(Point.readTwkbPoint(reader, options, previousPoint));\n\n    return lineString;\n  }\n\n  public toWkt(): string {\n    if (this.points.length === 0)\n      return this.getWktType(Types.wkt.LineString, true);\n\n    return this.getWktType(Types.wkt.LineString, false) + this._toInnerWkt();\n  };\n\n  public _toInnerWkt(): string {\n    var innerWkt = '(';\n\n    for (var i = 0; i < this.points.length; i++)\n      innerWkt += this.points[i].getWktCoordinate() + ',';\n\n    innerWkt = innerWkt.slice(0, -1);\n    innerWkt += ')';\n\n    return innerWkt;\n  };\n\n  public toWkb(options?: WKBExportOptions): ArrayBuffer {\n    var writer = new BinaryWriter(this.getWkbSize(), false);\n\n    writer.writeInt8(1);\n    writer.writeUInt32(this.getWkbType(Types.wkb.LineString, options));\n    writer.writeUInt32(this.points.length);\n\n    for (let i = 0; i < this.points.length; i++)\n      this.points[i].writeWkbPoint(writer);\n\n    return writer.buffer.buffer;\n  };\n\n  public toTwkb(): ArrayBuffer {\n    const writer = new BinaryWriter(0, true);\n\n    const precision = GeometryBase.getTwkbPrecision(5, 0, 0);\n    const isEmpty = this.points.length === 0;\n\n    this.writeTwkbHeader(writer, Types.wkb.LineString, precision, isEmpty);\n\n    if (this.points.length > 0) {\n      writer.writeVarInt(this.points.length);\n\n      var previousPoint = new Point(0, 0, 0, 0);\n      for (var i = 0; i < this.points.length; i++)\n        this.points[i].writeTwkbPoint(writer, precision, previousPoint);\n    }\n\n    return writer.buffer.buffer;\n  }\n\n  public getWkbSize(): number {\n    let coordinateSize = 16;\n\n    if (this.hasZ)\n      coordinateSize += 8;\n    if (this.hasM)\n      coordinateSize += 8;\n\n    return 1 + 4 + 4 + (this.points.length * coordinateSize);\n  };\n}\n","import { TWKBParseOptions, Types, WKBExportOptions, WKBParseOptions, WKTParseOptions } from './types';\nimport { Point } from './point';\nimport { BinaryReader } from './binaryreader';\nimport { BinaryWriter } from './binarywriter';\nimport { WktParser } from './wktparser';\nimport { GeometryBase } from './base';\nimport { Parser } from './parser';\n\nexport class MultiPoint extends GeometryBase {\n  public points: Point[];\n\n  constructor(points?: Point[], srid?: number) {\n    super();\n\n    this.points = points || [];\n    this.srid = srid;\n\n    if (this.points.length > 0) {\n      this.hasZ = this.points[0].hasZ;\n      this.hasM = this.points[0].hasM;\n    }\n  }\n\n  public static Z(points: Point[], srid: number) {\n    const multiPoint = new MultiPoint(points, srid);\n    multiPoint.hasZ = true;\n    return multiPoint;\n  };\n\n  public static M(points: Point[], srid: number) {\n    const multiPoint = new MultiPoint(points, srid);\n    multiPoint.hasM = true;\n    return multiPoint;\n  };\n\n  public static ZM(points: Point[], srid: number) {\n    const multiPoint = new MultiPoint(points, srid);\n    multiPoint.hasZ = true;\n    multiPoint.hasM = true;\n    return multiPoint;\n  };\n\n  public static parseWkt(reader: WktParser, options: WKTParseOptions): MultiPoint {\n    let multiPoint = new MultiPoint();\n    multiPoint.srid = options.srid;\n    multiPoint.hasZ = options.hasZ;\n    multiPoint.hasM = options.hasM;\n\n    if (reader.isMatch(['EMPTY']))\n      return multiPoint;\n\n    reader.expectGroupStart();\n    multiPoint.points = reader.matchCoordinates(options).map(x => new Point(x[0], x[1], x[2], x[3]));\n    reader.expectGroupEnd();\n\n    return multiPoint;\n  };\n\n  public static parseWkb(reader: BinaryReader, options: WKBParseOptions): MultiPoint {\n    let multiPoint = new MultiPoint();\n    multiPoint.srid = options.srid;\n    multiPoint.hasZ = options.hasZ;\n    multiPoint.hasM = options.hasM;\n\n    const pointCount = reader.readUInt32();\n\n    for (var i = 0; i < pointCount; i++)\n      multiPoint.points.push(Parser.parse(reader, options) as Point);\n\n    return multiPoint;\n  };\n\n  public static parseTwkb(reader: BinaryReader, options: TWKBParseOptions): MultiPoint {\n    const multiPoint = new MultiPoint();\n    multiPoint.hasZ = options.hasZ;\n    multiPoint.hasM = options.hasM;\n\n    if (options.isEmpty) return multiPoint;\n\n    const previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);\n    const pointCount = reader.readVarInt();\n\n    for (var i = 0; i < pointCount; i++)\n      multiPoint.points.push(Point.readTwkbPoint(reader, options, previousPoint));\n\n    return multiPoint;\n  }\n\n  public toWkt(): string {\n    if (this.points.length === 0)\n      return this.getWktType(Types.wkt.MultiPoint, true);\n\n    var wkt = this.getWktType(Types.wkt.MultiPoint, false) + '(';\n\n    for (var i = 0; i < this.points.length; i++)\n      wkt += this.points[i].getWktCoordinate() + ',';\n\n    wkt = wkt.slice(0, -1);\n    wkt += ')';\n\n    return wkt;\n  };\n\n  public toWkb(options?: WKBExportOptions): ArrayBuffer {\n    var wkb = new BinaryWriter(this.getWkbSize(), false);\n\n    wkb.writeInt8(1);\n    wkb.writeUInt32(this.getWkbType(Types.wkb.MultiPoint, options), true);\n    wkb.writeUInt32(this.points.length);\n\n    for (var i = 0; i < this.points.length; i++)\n      wkb.writeBuffer(this.points[i].toWkb({ srid: this.srid }));\n\n    return wkb.buffer.buffer;\n  };\n\n  public toTwkb(): ArrayBuffer {\n    const writer = new BinaryWriter(0, true);\n\n    const precision = GeometryBase.getTwkbPrecision(5, 0, 0);\n    const isEmpty = this.points.length === 0;\n\n    this.writeTwkbHeader(writer, Types.wkb.MultiPoint, precision, isEmpty);\n\n    if (this.points.length > 0) {\n      writer.writeVarInt(this.points.length);\n\n      const previousPoint = new Point(0, 0, 0, 0);\n      for (let i = 0; i < this.points.length; i++)\n        this.points[i].writeTwkbPoint(writer, precision, previousPoint);\n    }\n\n    return writer.buffer.buffer;\n  };\n\n  public getWkbSize(): number {\n    var coordinateSize = 16;\n\n    if (this.hasZ)\n      coordinateSize += 8;\n    if (this.hasM)\n      coordinateSize += 8;\n\n    coordinateSize += 5;\n\n    return 1 + 4 + 4 + (this.points.length * coordinateSize);\n  };\n}\n","import { BinaryReader } from \"./binaryreader\";\nimport { WktParser } from \"./wktparser\";\nimport { TWKBParseOptions, Types, WKBParseOptions, WKTParseOptions } from \"./types\";\nimport { Point } from \"./point\";\nimport { Polygon } from \"./polygon\";\nimport { MultiPoint } from './multipoint';\nimport { MultiPolygon } from './multipolygon';\nimport { LineString } from './linestring';\nimport { MultiLineString } from './multilinestring';\nimport { GeometryCollection } from './geometrycollection';\nimport { GeometryBase } from \"./base\";\nimport { decode } from \"./zigzag\";\n\nexport class Parser {\n\n  public static parse(input: string | DataView | WktParser | BinaryReader, options?: WKBParseOptions): GeometryBase {\n    if (typeof input === \"string\" || input instanceof WktParser) {\n      return Parser.parseWkt(input);\n    }\n    else if (input instanceof DataView || input instanceof BinaryReader) {\n      return Parser.parseWkb(input, options);\n    }\n\n    throw new Error(\"first argument must be a string or Buffer\");\n  }\n\n  public static parseWkt(value: string | WktParser): GeometryBase {\n    let srid: number | undefined;\n    const wktParser = value instanceof WktParser ? value : new WktParser(value);\n\n    var match = wktParser.matchRegex([/^SRID=(\\d+);/]);\n    if (match) srid = parseInt(match[1], 10);\n\n    var geometryType = wktParser.matchType();\n    var dimension = wktParser.matchDimension();\n\n    var options: WKTParseOptions = {\n      srid: srid,\n      hasZ: dimension.hasZ,\n      hasM: dimension.hasM,\n    };\n\n    switch (geometryType) {\n      case Types.wkt.Point:\n        return Point.parseWkt(wktParser, options);\n      case Types.wkt.LineString:\n        return LineString.parseWkt(wktParser, options);\n      case Types.wkt.Polygon:\n        return Polygon.parseWkt(wktParser, options);\n      case Types.wkt.MultiPoint:\n        return MultiPoint.parseWkt(wktParser, options);\n      case Types.wkt.MultiLineString:\n        return MultiLineString.parseWkt(wktParser, options);\n      case Types.wkt.MultiPolygon:\n        return MultiPolygon.parseWkt(wktParser, options);\n      case Types.wkt.GeometryCollection:\n        return GeometryCollection.parseWkt(wktParser, options);\n      default:\n        throw new Error(\"GeometryType \" + geometryType + \" not supported\");\n    }\n  }\n\n  public static parseWkb(value: BinaryReader | DataView, parentOptions?: WKBParseOptions): GeometryBase {\n    let geometryType: number;\n    const options: WKBParseOptions = {} as WKBParseOptions;\n    const binaryReader = value instanceof BinaryReader ? value : new BinaryReader(value, true);\n\n    binaryReader.isBigEndian = !binaryReader.readInt8();\n\n    const wkbType = binaryReader.readUInt32();\n\n    options.hasSrid = (wkbType & 0x20000000) === 0x20000000;\n    options.isEwkb = Boolean(wkbType & 0x20000000 || wkbType & 0x40000000 || wkbType & 0x80000000);\n\n    if (options.hasSrid) options.srid = binaryReader.readUInt32();\n\n    options.hasZ = false;\n    options.hasM = false;\n\n    if (!options.isEwkb && (!parentOptions || !parentOptions.isEwkb)) {\n      if (wkbType >= 1000 && wkbType < 2000) {\n        options.hasZ = true;\n        geometryType = wkbType - 1000;\n      } else if (wkbType >= 2000 && wkbType < 3000) {\n        options.hasM = true;\n        geometryType = wkbType - 2000;\n      } else if (wkbType >= 3000 && wkbType < 4000) {\n        options.hasZ = true;\n        options.hasM = true;\n        geometryType = wkbType - 3000;\n      } else {\n        geometryType = wkbType;\n      }\n    } else {\n      if (wkbType & 0x80000000) options.hasZ = true;\n      if (wkbType & 0x40000000) options.hasM = true;\n\n      geometryType = wkbType & 0xf;\n    }\n\n    switch (geometryType) {\n      case Types.wkb.Point:\n        return Point.parseWkb(binaryReader, options);\n      case Types.wkb.LineString:\n        return LineString.parseWkb(binaryReader, options);\n      case Types.wkb.Polygon:\n        return Polygon.parseWkb(binaryReader, options);\n      case Types.wkb.MultiPoint:\n        return MultiPoint.parseWkb(binaryReader, options);\n      case Types.wkb.MultiLineString:\n        return MultiLineString.parseWkb(binaryReader, options);\n      case Types.wkb.MultiPolygon:\n        return MultiPolygon.parseWkb(binaryReader, options);\n      case Types.wkb.GeometryCollection:\n        return GeometryCollection.parseWkb(binaryReader, options);\n      default:\n        throw new Error(\"GeometryType \" + geometryType + \" not supported\");\n    }\n  }\n\n  public static parseTwkb(value: BinaryReader | DataView) {\n    const options: TWKBParseOptions = {} as TWKBParseOptions;\n    const binaryReader = value instanceof BinaryReader ? value : new BinaryReader(value, true);\n\n    const type = binaryReader.readUInt8();\n    const metadataHeader = binaryReader.readUInt8();\n\n    const geometryType = type & 0x0F;\n    options.precision = decode(type >> 4);\n    options.precisionFactor = Math.pow(10, options.precision);\n\n    options.hasBoundingBox = Boolean(metadataHeader >> 0 & 1);\n    options.hasSizeAttribute = Boolean(metadataHeader >> 1 & 1);\n    options.hasIdList = Boolean(metadataHeader >> 2 & 1);\n    options.hasExtendedPrecision = Boolean(metadataHeader >> 3 & 1);\n    options.isEmpty = Boolean(metadataHeader >> 4 & 1);\n\n    if (options.hasExtendedPrecision) {\n      const extendedPrecision = binaryReader.readUInt8();\n      options.hasZ = (extendedPrecision & 0x01) === 0x01;\n      options.hasM = (extendedPrecision & 0x02) === 0x02;\n\n      options.zPrecision = decode((extendedPrecision & 0x1C) >> 2);\n      options.zPrecisionFactor = Math.pow(10, options.zPrecision);\n\n      options.mPrecision = decode((extendedPrecision & 0xE0) >> 5);\n      options.mPrecisionFactor = Math.pow(10, options.mPrecision);\n    }\n    else {\n      options.hasZ = false;\n      options.hasM = false;\n    }\n\n    if (options.hasSizeAttribute)\n      binaryReader.readVarInt();\n    if (options.hasBoundingBox) {\n      let dimensions = 2;\n\n      if (options.hasZ)\n        dimensions++;\n      if (options.hasM)\n        dimensions++;\n\n      for (var i = 0; i < dimensions; i++) {\n        binaryReader.readVarInt();\n        binaryReader.readVarInt();\n      }\n    }\n\n    switch (geometryType) {\n      case Types.wkb.Point:\n        return Point.parseTwkb(binaryReader, options);\n      case Types.wkb.LineString:\n        return LineString.parseTwkb(binaryReader, options);\n      case Types.wkb.Polygon:\n        return Polygon.parseTwkb(binaryReader, options);\n      case Types.wkb.MultiPoint:\n        return MultiPoint.parseTwkb(binaryReader, options);\n      case Types.wkb.MultiLineString:\n        return MultiLineString.parseTwkb(binaryReader, options);\n      case Types.wkb.MultiPolygon:\n        return MultiPolygon.parseTwkb(binaryReader, options);\n      case Types.wkb.GeometryCollection:\n        return GeometryCollection.parseTwkb(binaryReader, options);\n      default:\n        throw new Error('GeometryType ' + geometryType + ' not supported');\n    }\n  }\n}\n","import { TWKBParseOptions, Types, WKBExportOptions, WKBParseOptions, WKTParseOptions } from \"./types\";\nimport { Point } from \"./point\";\nimport { Polygon } from \"./polygon\";\nimport { BinaryWriter } from \"./binarywriter\";\nimport { BinaryReader } from \"./binaryreader\";\nimport { WktParser } from \"./wktparser\";\nimport { GeometryBase } from \"./base\";\nimport { Parser } from \"./parser\";\n\nexport class MultiPolygon extends GeometryBase {\n  public polygons: Polygon[];\n\n  constructor(polygons?: Polygon[], srid?: number) {\n    super();\n\n    this.polygons = polygons || [];\n    this.srid = srid;\n\n    if (this.polygons.length > 0) {\n      this.hasZ = this.polygons[0].hasZ;\n      this.hasM = this.polygons[0].hasM;\n    }\n  }\n\n  public static Z(polygons: Polygon[], srid: number) {\n    const multiPolygon = new MultiPolygon(polygons, srid);\n    multiPolygon.hasZ = true;\n    return multiPolygon;\n  };\n\n  public static M(polygons: Polygon[], srid: number) {\n    const multiPolygon = new MultiPolygon(polygons, srid);\n    multiPolygon.hasM = true;\n    return multiPolygon;\n  };\n\n  public static ZM(polygons: Polygon[], srid: number) {\n    const multiPolygon = new MultiPolygon(polygons, srid);\n    multiPolygon.hasZ = true;\n    multiPolygon.hasM = true;\n    return multiPolygon;\n  };\n\n  public static parseWkt(reader: WktParser, options: WKTParseOptions): MultiPolygon {\n    var multiPolygon = new MultiPolygon();\n    multiPolygon.srid = options.srid;\n    multiPolygon.hasZ = options.hasZ;\n    multiPolygon.hasM = options.hasM;\n\n    if (reader.isMatch(['EMPTY']))\n      return multiPolygon;\n\n    reader.expectGroupStart();\n\n    do {\n      reader.expectGroupStart();\n\n      var exteriorRing: Point[] = [];\n      var interiorRings: Point[][] = [];\n\n      reader.expectGroupStart();\n      exteriorRing = reader.matchCoordinates(options).map(x => new Point(x[0], x[1], x[2], x[3]));\n      reader.expectGroupEnd();\n\n      while (reader.isMatch([','])) {\n        reader.expectGroupStart();\n        interiorRings.push(reader.matchCoordinates(options).map(x => new Point(x[0], x[1], x[2], x[3])));\n        reader.expectGroupEnd();\n      }\n\n      multiPolygon.polygons.push(new Polygon(exteriorRing, interiorRings));\n\n      reader.expectGroupEnd();\n\n    } while (reader.isMatch([',']));\n\n    reader.expectGroupEnd();\n\n    return multiPolygon;\n  };\n\n  public static parseWkb(reader: BinaryReader, options: WKBParseOptions): MultiPolygon {\n    const multiPolygon = new MultiPolygon();\n    multiPolygon.srid = options.srid;\n    multiPolygon.hasZ = options.hasZ;\n    multiPolygon.hasM = options.hasM;\n\n    var polygonCount = reader.readUInt32();\n\n    for (var i = 0; i < polygonCount; i++)\n      multiPolygon.polygons.push(Parser.parse(reader, options) as Polygon);\n\n    return multiPolygon;\n  };\n\n  public static parseTwkb(reader: BinaryReader, options: TWKBParseOptions): MultiPolygon {\n    const multiPolygon = new MultiPolygon();\n    multiPolygon.hasZ = options.hasZ;\n    multiPolygon.hasM = options.hasM;\n\n    if (options.isEmpty)\n      return multiPolygon;\n\n    const previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);\n    const polygonCount = reader.readVarInt();\n\n    for (let i = 0; i < polygonCount; i++) {\n      const polygon = new Polygon();\n      polygon.hasZ = options.hasZ;\n      polygon.hasM = options.hasM;\n\n      const ringCount = reader.readVarInt();\n      const exteriorRingCount = reader.readVarInt();\n\n      for (let j = 0; j < exteriorRingCount; j++)\n        polygon.exteriorRing.push(Point.readTwkbPoint(reader, options, previousPoint));\n\n      for (let j = 1; j < ringCount; j++) {\n        const interiorRing = [];\n\n        const interiorRingCount = reader.readVarInt();\n\n        for (let k = 0; k < interiorRingCount; k++)\n          interiorRing.push(Point.readTwkbPoint(reader, options, previousPoint));\n\n        polygon.interiorRings.push(interiorRing);\n      }\n\n      multiPolygon.polygons.push(polygon);\n    }\n\n    return multiPolygon;\n  }\n\n  public toWkt(): string {\n    if (this.polygons.length === 0)\n      return this.getWktType(Types.wkt.MultiPolygon, true);\n\n    var wkt = this.getWktType(Types.wkt.MultiPolygon, false) + '(';\n\n    for (var i = 0; i < this.polygons.length; i++)\n      wkt += this.polygons[i]._toInnerWkt() + ',';\n\n    wkt = wkt.slice(0, -1);\n    wkt += ')';\n\n    return wkt;\n  };\n\n  public toWkb(options?: WKBExportOptions): ArrayBuffer {\n    var wkb = new BinaryWriter(this.getWkbSize(), false);\n\n    wkb.writeInt8(1);\n    wkb.writeUInt32(this.getWkbType(Types.wkb.MultiPolygon, options), true);\n    wkb.writeUInt32(this.polygons.length);\n\n    for (var i = 0; i < this.polygons.length; i++)\n      wkb.writeBuffer(this.polygons[i].toWkb({ srid: this.srid }));\n\n    return wkb.buffer.buffer;\n  };\n\n  public toTwkb(): ArrayBuffer {\n    const writer = new BinaryWriter(0, true);\n\n    const precision = GeometryBase.getTwkbPrecision(5, 0, 0);\n    const isEmpty = this.polygons.length === 0;\n\n    this.writeTwkbHeader(writer, Types.wkb.MultiPolygon, precision, isEmpty);\n\n    if (this.polygons.length > 0) {\n      writer.writeVarInt(this.polygons.length);\n\n      const previousPoint = new Point(0, 0, 0, 0);\n      for (let i = 0; i < this.polygons.length; i++) {\n        writer.writeVarInt(1 + this.polygons[i].interiorRings.length);\n\n        writer.writeVarInt(this.polygons[i].exteriorRing.length);\n\n        for (let j = 0; j < this.polygons[i].exteriorRing.length; j++)\n          this.polygons[i].exteriorRing[j].writeTwkbPoint(writer, precision, previousPoint);\n\n        for (let j = 0; j < this.polygons[i].interiorRings.length; j++) {\n          writer.writeVarInt(this.polygons[i].interiorRings[j].length);\n\n          for (let k = 0; k < this.polygons[i].interiorRings[j].length; k++)\n            this.polygons[i].interiorRings[j][k].writeTwkbPoint(writer, precision, previousPoint);\n        }\n      }\n    }\n\n    return writer.buffer.buffer;\n  }\n\n  public getWkbSize(): number {\n    var size = 1 + 4 + 4;\n\n    for (var i = 0; i < this.polygons.length; i++)\n      size += this.polygons[i].getWkbSize();\n\n    return size;\n  };\n}\n","import { TWKBParseOptions, Types, WKBExportOptions, WKBParseOptions, WKTParseOptions } from \"./types\";\nimport { Point } from \"./point\";\nimport { LineString } from \"./linestring\";\nimport { BinaryReader } from \"./binaryreader\";\nimport { BinaryWriter } from \"./binarywriter\";\nimport { WktParser } from \"./wktparser\";\nimport { GeometryBase } from \"./base\";\nimport { Parser } from \"./parser\";\n\nexport class MultiLineString extends GeometryBase {\n  public lineStrings: LineString[];\n\n  constructor(lineStrings?: LineString[], srid?: number) {\n    super();\n\n    this.lineStrings = lineStrings || [];\n    this.srid = srid;\n\n    if (this.lineStrings.length > 0) {\n      this.hasZ = this.lineStrings[0].hasZ;\n      this.hasM = this.lineStrings[0].hasM;\n    }\n  }\n\n  public static Z(lineStrings: LineString[], srid: number) {\n    const multiLineString = new MultiLineString(lineStrings, srid);\n    multiLineString.hasZ = true;\n    return multiLineString;\n  };\n\n  public static M(lineStrings: LineString[], srid: number) {\n    const multiLineString = new MultiLineString(lineStrings, srid);\n    multiLineString.hasM = true;\n    return multiLineString;\n  };\n\n  public static ZM(lineStrings: LineString[], srid: number) {\n    const multiLineString = new MultiLineString(lineStrings, srid);\n    multiLineString.hasZ = true;\n    multiLineString.hasM = true;\n    return multiLineString;\n  };\n\n  public static parseWkt(reader: WktParser, options: WKTParseOptions): MultiLineString {\n    var multiLineString = new MultiLineString();\n    multiLineString.srid = options.srid;\n    multiLineString.hasZ = options.hasZ;\n    multiLineString.hasM = options.hasM;\n\n    if (reader.isMatch(['EMPTY']))\n      return multiLineString;\n\n    reader.expectGroupStart();\n\n    do {\n      reader.expectGroupStart();\n      multiLineString.lineStrings.push(new LineString(reader.matchCoordinates(options).map(x => new Point(x[0], x[1], x[2], x[3]))));\n      reader.expectGroupEnd();\n    } while (reader.isMatch([',']));\n\n    reader.expectGroupEnd();\n\n    return multiLineString;\n  };\n\n  public static parseWkb(reader: BinaryReader, options: WKBParseOptions): MultiLineString {\n    var multiLineString = new MultiLineString();\n    multiLineString.srid = options.srid;\n    multiLineString.hasZ = options.hasZ;\n    multiLineString.hasM = options.hasM;\n\n    var lineStringCount = reader.readUInt32();\n\n    for (var i = 0; i < lineStringCount; i++)\n      multiLineString.lineStrings.push(Parser.parse(reader, options) as LineString);\n\n    return multiLineString;\n  };\n\n  public static parseTwkb(reader: BinaryReader, options: TWKBParseOptions): MultiLineString {\n    const multiLineString = new MultiLineString();\n    multiLineString.hasZ = options.hasZ;\n    multiLineString.hasM = options.hasM;\n\n    if (options.isEmpty)\n      return multiLineString;\n\n    const previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);\n    const lineStringCount = reader.readVarInt();\n\n    for (var i = 0; i < lineStringCount; i++) {\n      const lineString = new LineString();\n      lineString.hasZ = options.hasZ;\n      lineString.hasM = options.hasM;\n\n      const pointCount = reader.readVarInt();\n\n      for (var j = 0; j < pointCount; j++)\n        lineString.points.push(Point.readTwkbPoint(reader, options, previousPoint));\n\n      multiLineString.lineStrings.push(lineString);\n    }\n\n    return multiLineString;\n  }\n\n  public toWkt(): string {\n    if (this.lineStrings.length === 0)\n      return this.getWktType(Types.wkt.MultiLineString, true);\n\n    var wkt = this.getWktType(Types.wkt.MultiLineString, false) + '(';\n\n    for (var i = 0; i < this.lineStrings.length; i++)\n      wkt += this.lineStrings[i]._toInnerWkt() + ',';\n\n    wkt = wkt.slice(0, -1);\n    wkt += ')';\n\n    return wkt;\n  };\n\n  public toWkb(options?: WKBExportOptions): ArrayBuffer {\n    var wkb = new BinaryWriter(this.getWkbSize(), false);\n\n    wkb.writeInt8(1);\n\n    wkb.writeUInt32(this.getWkbType(Types.wkb.MultiLineString, options));\n    wkb.writeUInt32(this.lineStrings.length);\n\n    for (var i = 0; i < this.lineStrings.length; i++)\n      wkb.writeBuffer(this.lineStrings[i].toWkb({ srid: this.srid }));\n\n    return wkb.buffer.buffer;\n  };\n\n  public toTwkb(): ArrayBuffer {\n    const writer = new BinaryWriter(0, true);\n\n    const precision = GeometryBase.getTwkbPrecision(5, 0, 0);\n    const isEmpty = this.lineStrings.length === 0;\n\n    this.writeTwkbHeader(writer, Types.wkb.MultiLineString, precision, isEmpty);\n\n    if (this.lineStrings.length > 0) {\n      writer.writeVarInt(this.lineStrings.length);\n\n      const previousPoint = new Point(0, 0, 0, 0);\n      for (let i = 0; i < this.lineStrings.length; i++) {\n        writer.writeVarInt(this.lineStrings[i].points.length);\n\n        for (var j = 0; j < this.lineStrings[i].points.length; j++)\n          this.lineStrings[i].points[j].writeTwkbPoint(writer, precision, previousPoint);\n      }\n    }\n\n    return writer.buffer.buffer;\n  }\n\n  public getWkbSize(): number {\n    var size = 1 + 4 + 4;\n\n    for (var i = 0; i < this.lineStrings.length; i++)\n      size += this.lineStrings[i].getWkbSize();\n\n    return size;\n  };\n}\n","import { TWKBParseOptions, Types, WKBExportOptions, WKBParseOptions, WKTParseOptions } from './types';\nimport { BinaryWriter } from './binarywriter';\nimport { BinaryReader } from './binaryreader';\nimport { WktParser } from './wktparser';\nimport { GeometryBase } from './base';\nimport { Parser } from './parser';\n\nexport class GeometryCollection extends GeometryBase {\n  public geometries: GeometryBase[];\n\n  constructor(geometries?: GeometryBase[], srid?: number) {\n    super();\n\n    this.geometries = geometries || [];\n    this.srid = srid;\n\n    if (this.geometries.length > 0) {\n      this.hasZ = this.geometries[0].hasZ;\n      this.hasM = this.geometries[0].hasM;\n    }\n  }\n\n  public static Z(geometries: GeometryBase[], srid: number) {\n    const geometryCollection = new GeometryCollection(geometries, srid);\n    geometryCollection.hasZ = true;\n    return geometryCollection;\n  };\n\n  public static M(geometries: GeometryBase[], srid: number) {\n    const geometryCollection = new GeometryCollection(geometries, srid);\n    geometryCollection.hasM = true;\n    return geometryCollection;\n  };\n\n  public static ZM(geometries: GeometryBase[], srid: number) {\n    const geometryCollection = new GeometryCollection(geometries, srid);\n    geometryCollection.hasZ = true;\n    geometryCollection.hasM = true;\n    return geometryCollection;\n  };\n\n  public static parseWkt(reader: WktParser, options: WKTParseOptions): GeometryCollection {\n    var geometryCollection = new GeometryCollection();\n    geometryCollection.srid = options.srid;\n    geometryCollection.hasZ = options.hasZ;\n    geometryCollection.hasM = options.hasM;\n\n    if (reader.isMatch(['EMPTY']))\n      return geometryCollection;\n\n    reader.expectGroupStart();\n\n    do {\n      geometryCollection.geometries.push(Parser.parse(reader));\n    } while (reader.isMatch([',']));\n\n    reader.expectGroupEnd();\n\n    return geometryCollection;\n  }\n\n  public static parseWkb(reader: BinaryReader, options: WKBParseOptions): GeometryCollection {\n    var geometryCollection = new GeometryCollection();\n    geometryCollection.srid = options.srid;\n    geometryCollection.hasZ = options.hasZ;\n    geometryCollection.hasM = options.hasM;\n\n    var geometryCount = reader.readUInt32();\n\n    for (var i = 0; i < geometryCount; i++)\n      geometryCollection.geometries.push(Parser.parse(reader, options));\n\n    return geometryCollection;\n  }\n\n  public static parseTwkb(reader: BinaryReader, options: TWKBParseOptions): GeometryCollection {\n    const geometryCollection = new GeometryCollection();\n    geometryCollection.hasZ = options.hasZ;\n    geometryCollection.hasM = options.hasM;\n\n    if (options.isEmpty)\n      return geometryCollection;\n\n    var geometryCount = reader.readVarInt();\n\n    for (var i = 0; i < geometryCount; i++)\n      geometryCollection.geometries.push(Parser.parseTwkb(reader));\n\n    return geometryCollection;\n  }\n\n  public toWkt(): string {\n    if (this.geometries.length === 0)\n      return this.getWktType(Types.wkt.GeometryCollection, true);\n\n    var wkt = this.getWktType(Types.wkt.GeometryCollection, false) + '(';\n\n    for (var i = 0; i < this.geometries.length; i++)\n      wkt += this.geometries[i].toWkt() + ',';\n\n    wkt = wkt.slice(0, -1);\n    wkt += ')';\n\n    return wkt;\n  };\n\n  public toWkb(options?: WKBExportOptions): ArrayBuffer {\n    const wkb = new BinaryWriter(this.getWkbSize(), false);\n\n    wkb.writeInt8(1);\n    wkb.writeUInt32(this.getWkbType(Types.wkb.GeometryCollection, options));\n    wkb.writeUInt32(this.geometries.length);\n\n    for (var i = 0; i < this.geometries.length; i++)\n      wkb.writeBuffer(this.geometries[i].toWkb({ srid: this.srid }));\n\n    return wkb.buffer.buffer;\n  };\n\n  public toTwkb(): ArrayBuffer {\n    const writer = new BinaryWriter(0, true);\n\n    const precision = GeometryBase.getTwkbPrecision(5, 0, 0);\n    const isEmpty = this.geometries.length === 0;\n\n    this.writeTwkbHeader(writer, Types.wkb.GeometryCollection, precision, isEmpty);\n\n    if (this.geometries.length > 0) {\n      writer.writeVarInt(this.geometries.length);\n\n      for (let i = 0; i < this.geometries.length; i++)\n        writer.writeBuffer(this.geometries[i].toTwkb());\n    }\n\n    return writer.buffer.buffer;\n  }\n\n  public getWkbSize(): number {\n    let size = 1 + 4 + 4;\n\n    for (let i = 0; i < this.geometries.length; i++)\n      size += this.geometries[i].getWkbSize();\n\n    return size;\n  };\n}\n"],"names":[],"version":3,"file":"module.js.map"}